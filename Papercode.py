# -*- coding: utf-8 -*-
"""Papercode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Iw9cTSrE8vyjXko3XY57Gr-0ISTkUSle
"""

!pip install opencv-python Pyfhel

import cv2
import numpy as np
from Pyfhel import Pyfhel
from google.colab import files

# Eye detector (Haar cascade)
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_eye.xml')

def iris_hs_feature(bgr_img):
    """
    Extract a 2D iris feature (mean Hue, mean Saturation) from the eye region.
    NOTE: This runs on the CLIENT/OWNER machine before encryption.
    We do NOT print the numeric values to avoid leaking them.
    """
    gray = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY)
    eyes = eye_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

    if len(eyes) == 0:
        raise ValueError("No eyes detected – please use a clear frontal face image.")

    # Use first detected eye
    ex, ey, ew, eh = eyes[0]
    cx = ex + ew // 2
    cy = ey + eh // 2
    r  = min(ew, eh) // 4

    mask = np.zeros(gray.shape, dtype=np.uint8)
    cv2.circle(mask, (cx, cy), r, 255, -1)

    hsv = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2HSV)
    H = hsv[:, :, 0].astype(np.float32)  # Hue
    S = hsv[:, :, 1].astype(np.float32)  # Saturation

    iris_H = H[mask > 0]
    iris_S = S[mask > 0]

    hue_mean = float(np.mean(iris_H))
    sat_mean = float(np.mean(iris_S))

    return hue_mean, sat_mean

print("STEP 1 (OWNER): Upload ORIGINAL dataset image (trusted baseline).")
orig_upload = files.upload()
orig_filename = list(orig_upload.keys())[0]
print("  Loaded original image file:", orig_filename)

orig_bgr = cv2.imread(orig_filename)
if orig_bgr is None:
    raise ValueError("Could not read original image. Please upload a valid image file.")

# Extract iris feature for original image (baseline)
h_orig, s_orig = iris_hs_feature(orig_bgr)

# Scale to integer domain (but DO NOT print numeric values)
alpha_h = 10.0
alpha_s = 10.0

m_orig = np.array([
    int(round(alpha_h * h_orig)),
    int(round(alpha_s * s_orig))
], dtype=np.int64)

print("  Baseline iris feature extracted and encoded (dimension = 2).")
print("  (Values are kept internal and not printed.)")

print("\nSTEP 2 (OWNER): Generate FHE context and keys (BFV scheme).")

HE = Pyfhel()

# BFV (Brakerski–Fan–Vercauteren) integer FHE context
HE.contextGen(
    scheme="BFV",
    n=4096,       # polynomial modulus degree
    t_bits=20     # plaintext modulus bits
)

HE.keyGen()      # generates public & secret keys

print("  [KeyGen] BFV context generated.")
print("  [KeyGen] Public key ready (for encryption & homomorphic eval).")
print("  [KeyGen] Secret key is stored ONLY by the OWNER (not shared).")

print("\nSTEP 3 (OWNER): Upload QUERY image (may be real or deepfake).")
query_upload = files.upload()
query_filename = list(query_upload.keys())[0]
print("  Loaded query image file:", query_filename)

query_bgr = cv2.imread(query_filename)
if query_bgr is None:
    raise ValueError("Could not read query image. Please upload a valid image file.")

# Extract iris feature for query image (locally, not printed)
h_query, s_query = iris_hs_feature(query_bgr)

# Encode query feature into integer domain
m_query = np.array([
    int(round(alpha_h * h_query)),
    int(round(alpha_s * s_query))
], dtype=np.int64)

print("  Query iris feature extracted and encoded (dimension = 2).")
print("  (Again, numeric values are NOT printed anywhere.)")

# ===== IMMEDIATE ENCRYPTION OF QUERY FEATURE =====
C_query = HE.encryptInt(m_query)  # Enc(m^(q))

print("  [Encryption] Query feature encrypted as ciphertext C_query.")
print("  [Encryption] Ciphertext type:", type(C_query))

# Conceptually: C_query is sent to the SERVER.
# m_orig is stored as plaintext model baseline on SERVER.

print("\nSTEP 4 (SERVER): Homomorphic deepfake analysis on encrypted query feature.")

# Encode baseline feature as BFV plaintext (not encrypted)
P_orig = HE.encodeInt(m_orig)

# Encrypted difference: Enc(m_query - m_orig)
C_diff = C_query - P_orig

# Encrypted squared differences: Enc((m_query - m_orig)^2 component-wise)
C_diff_sq = C_diff * C_diff

# Sum-of-squares score: Enc( d_h^2 + d_s^2 )
ones_vec = np.array([1, 1], dtype=np.int64)
P_ones   = HE.encodeInt(ones_vec)
C_score  = C_diff_sq * P_ones

print("  [Server] Encoded baseline feature as plaintext P_orig.")
print("  [Server] Computed C_diff = Enc(m_query - m_orig).")
print("  [Server] Computed C_diff_sq = Enc((m_query - m_orig)^2).")
print("  [Server] Computed C_score = Enc(sum of squared differences).")
print("  [Server] Returning ONLY C_score to OWNER.")

print("\nSTEP 5 (OWNER): Decrypt the final encrypted score using secret key.")

# Decrypt encrypted score (sum of squared diff in integer domain)
score_int = HE.decryptInt(C_score)[0]

print("  [Decrypt] Recovered integer score d_h^2 + d_s^2 (not normalized):", score_int)

# Convert back to approximate feature distance in (hue, saturation) space.
# With alpha_h = alpha_s = alpha, we have:
# score_int ≈ alpha^2 * [ (h_q - h_o)^2 + (s_q - s_o)^2 ]
alpha = alpha_h
S = np.sqrt(score_int) / alpha

print("  [Decrypt] Approximate iris-colour distance S ≈", S)

# Set a threshold for deciding manipulation (you will tune this)
tau = 10.0
print("  [Decision] Threshold tau =", tau)

if S > tau:
    print("  >>> RESULT: Significant iris-colour change (likely deepfake).")
else:
    print("  >>> RESULT: No strong iris-colour manipulation detected.")
